
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Q4</title><meta name="generator" content="MATLAB 9.9"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2021-11-01"><meta name="DC.source" content="Q4.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#2">a)</a></li><li><a href="#7">b)</a></li><li><a href="#10">c)</a></li><li><a href="#12">d)</a></li><li><a href="#16">Functions</a></li></ul></div><pre class="codeinput">clear; clc; close <span class="string">all</span>;
</pre><h2 id="2">a)</h2><p>Plotting the signal as a function of time and then overlaying the original signal on the subsampled version of the signal with every 4th element of the signal being sampled.</p><pre class="codeinput">load(<span class="string">'myMeasurements.mat'</span>)
figure();
plot(time, sig, <span class="string">'ko-'</span>)
hold <span class="string">on</span>;
time_subsampled = time(4:4:end); <span class="comment">% Subsampling time with every 4th timepoint</span>
sig_subsampled = sig(4:4:end); <span class="comment">% Subsampling signal with every 4th datapoint</span>
plot(time_subsampled, sig_subsampled, <span class="string">'r*-'</span>)
xlabel(<span class="string">'Time (s)'</span>)
ylabel(<span class="string">'Voltage (V)'</span>)
title(<span class="string">'EEG Signal'</span>)
</pre><img vspace="5" hspace="5" src="Q4_01.png" alt=""> <p>The subsampled signal does not provide a good summary of the original signal as it ends up choosing some elements in the signal while elementing remaining elements. It appears that subsampling operation is better at capturing low-frequency signals in the original signal.</p><p>The sampling operation is linear because it can be expressed as a matrix multiplication aX = b, where the system X is an identity matrix with some of the diagonal elements replaced with 0s, a is the original signal and b is the subsampled signal.</p><p>If the input a is shifted, the 1s in the diagonal of X will now be multiplied by different input values which will result in a different output. Therefore, the subsampling operation is not shift-invariant.</p><h2 id="7">b)</h2><p>The EEG signal can be transformed into the frequency domain by performing fft over the signal. We can also compute the shifted fft by using fftshift to center the DC component of the fft. The frequency range goes from 0:N-1 and is scaled by the sampling frequency and the length of the signal vector N. The shifted frequency scale goes from -N/2 to N/2 - 1 with same scaling. Plotting the FFT and the shifted FFT, we get:</p><pre class="codeinput">fs = 120; <span class="comment">% sampling frequency</span>
N = length(sig); <span class="comment">% length of the signal vector</span>
f = (0:N-1) * fs/N; <span class="comment">% creating the frequency vector</span>
fshift = (-N/2: (N/2)-1) * fs/N; <span class="comment">% creating a shifted frequency vector</span>
F_sig = fft(sig); <span class="comment">% computing the Fourier Transform of signal</span>
F_shift_sig = fftshift(F_sig); <span class="comment">% Shifting the Fourier Transform so that DC component is in the middle</span>

figure();
plot(f, abs(F_sig))
xlabel(<span class="string">'Frequency (Hz)'</span>)
ylabel(<span class="string">'Amplitiude'</span>)
title(<span class="string">'FFT of signal'</span>)
figure();
plot(fshift, abs(F_shift_sig))
xlabel(<span class="string">'Frequency (Hz)'</span>)
ylabel(<span class="string">'Amplitiude'</span>)
title(<span class="string">'FFTshift of signal'</span>)
</pre><img vspace="5" hspace="5" src="Q4_02.png" alt=""> <img vspace="5" hspace="5" src="Q4_03.png" alt=""> <p>The strongest signal is obtained at 12 Hz which belongs to the Alpha band at 36 Hz which belongs to the Gamma band. I am unsure of the exact source of this signal. Here is the thought process that I have went through. At first instance, I expected there to be line noise in the signal since its an EEG signal. But 36 Hz is too low a frequency for line noise. It could just be some neural activity related to the task which should give signal in the gamma band of the frequency range. However, this is unlikely to give a peak at a single frequency. But then this is synthetic data, so maybe that's what it is signifying? Another way to look at it is that 36 Hz is a second harmonic of 12 Hz. However, harmonics in fft generally exhibit lower amplitude than the fundamental. Here the fundamental of second harmonic is higher than fundamental (absurd?!), and the first harmonic is missing. So I am unsure of the source of the 36 Hz signal here.</p><h2 id="10">c)</h2><p>The bandWiseReconstruct computes the signalPart in a given time-range, for a given fftsig within a frequency band. It does so by first computing a vector of zeros of length of F_sig and then adding ones at frequencies of interest within a given bname. It then takes an element-wise product of F_sig with this vector to create an FsigPart which has amplitudes at frequencies of interest and is 0 otherwise:</p><pre class="codeinput">bandnames = [<span class="string">"Delta"</span>, <span class="string">"Theta"</span>, <span class="string">"Alpha"</span>, <span class="string">"Beta"</span>, <span class="string">"Merged"</span>]; <span class="comment">% array of frequency bands, merged is the entire frequency range</span>
<span class="keyword">for</span> bname = bandnames
    signalPart = bandWiseReconstruct(time, F_sig, bname); <span class="comment">% computing signalPart from F_sig for given frequency bandname</span>
<span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="Q4_04.png" alt=""> <img vspace="5" hspace="5" src="Q4_05.png" alt=""> <img vspace="5" hspace="5" src="Q4_06.png" alt=""> <img vspace="5" hspace="5" src="Q4_07.png" alt=""> <img vspace="5" hspace="5" src="Q4_08.png" alt=""> <p>We can see that since the FFT of the signal only has peaks in the alpha band and the gamma band, the reconstructed signal from these bands has some structure to it whereas for other frequencies, we only see noise with amplitude of the signal very close to 0.</p><h2 id="12">d)</h2><p>The upsampled sigals after downsampling can be computed by creating an array of zeros with 1s at positions of downsampling vector and then taking an element-wise product of this vetor with the signal. The fft and fftshift can then be computed for this upsampled signal.</p><pre class="codeinput">ds_facts = [2, 3, 4]; <span class="comment">% downsampling factors</span>
<span class="keyword">for</span> fct = ds_facts
    sig_downsamp_pos = zeros(1, length(sig));
    sig_downsamp_pos(fct:fct:end) = 1; <span class="comment">% Creating an array of ones at positons where sub-sampled frequencies will be</span>
    sig_upsamp = sig .* sig_downsamp_pos; <span class="comment">% Upsampling by computing element-wise product of signal with downsampled positions</span>
    F_sig_upsamp = fft(sig_upsamp); <span class="comment">% Computing FFT of upsampled signal</span>
    F_sig_upsamp_shift = fftshift(F_sig_upsamp); <span class="comment">% Computing FFTshift of upsampled signal</span>

    figure();
    plot(fshift, abs(F_sig_upsamp_shift)); <span class="comment">% Plotting amplitudes of shifted FFT</span>
    xlabel(<span class="string">'Frequency (Hz)'</span>)
    ylabel(<span class="string">'Amplitiude'</span>)
    title([<span class="string">'FFT of signal sampled at k = '</span>, num2str(fct)])
<span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="Q4_09.png" alt=""> <img vspace="5" hspace="5" src="Q4_10.png" alt=""> <img vspace="5" hspace="5" src="Q4_11.png" alt=""> <p>The downsampling and upsampling happening over here is naive. This results in artifacts in the reconstructed signal. The original sampling frequency is 120 Hz. Upon downsampling and upsampling, the sampling frequency becomes 120/k, where k is the downsampling factor. Hence, the Nyquist frequency of the downsampled signal will be 120/2k. For k = 2, Nyquist frequency is 120/4 = 40 Hz. The maximum frequency in the original signal was 36 Hz which is below Nyquist and hence there is no aliasing. However, since the signal is downsampled and upsampled, it creates two additional peaks at 60 - 12 = 48 Hz and 60 - 36 = 24 Hz. For k = 3, the Nyquist frequency is 120/6 = 20 Hz which is below the maximum frequency in the signal resulting in aliasing. Thus we see that the amplitude of the first peak in fft is higher than the second. The same happens in the case of k = 4. In order to avoid aliasing, signal should be low-pass filtered to ensure that there is no component in the downsampled signal that is above the Nyquist frequency of the downsampled signal.</p><h2 id="16">Functions</h2><pre class="codeinput"><span class="keyword">function</span> signalPart = bandWiseReconstruct(time, Fsig, bandname)
    <span class="comment">% Defining frequency bands and their min and max frequency ranges</span>
    bnames = [<span class="string">"Delta"</span>, <span class="string">"Theta"</span>, <span class="string">"Alpha"</span>, <span class="string">"Beta"</span>, <span class="string">"Merged"</span>];
    freqs = [[0, 4, 8, 16, 0]; <span class="keyword">...</span>
        [4, 7, 15, 31, 60]];
    band_freqs = freqs(:, bnames == bandname); <span class="comment">% Computing the min and max frequency bounds for the given bandname</span>
    bvec = zeros(1, length(Fsig));
    bvec(band_freqs(1) + 1: band_freqs(2) + 1) = 1; <span class="comment">% Creating a vector of zeros with ones at frequencies of interests</span>
    FsigPart = Fsig .* bvec; <span class="comment">% Taking an element-wise product of Fsig with bvec to create Fsig with amp values at frequencies of intrest and 0 otherwise</span>
    signalPart = ifft(FsigPart); <span class="comment">% Computing inverse FFT of FsigPart</span>

    figure()
    plot(time, real(signalPart), <span class="string">'ro-'</span>) <span class="comment">% The recomputed signal has imaginary parts which are not of our interest since the signal has only real values</span>
    xlabel(<span class="string">'Time (s)'</span>)
    ylabel(<span class="string">'Voltage (V)'</span>)
    title([<span class="string">'Reconstructed EEG Signal at '</span>, bandname])

<span class="keyword">end</span>
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2020b</a><br></p></div><!--
##### SOURCE BEGIN #####
clear; clc; close all;

%% a)
% Plotting the signal as a function of time and then overlaying the original
% signal on the subsampled version of the signal with every 4th element of
% the signal being sampled.

%%
load('myMeasurements.mat')
figure();
plot(time, sig, 'ko-')
hold on;
time_subsampled = time(4:4:end); % Subsampling time with every 4th timepoint
sig_subsampled = sig(4:4:end); % Subsampling signal with every 4th datapoint
plot(time_subsampled, sig_subsampled, 'r*-')
xlabel('Time (s)')
ylabel('Voltage (V)')
title('EEG Signal')

%%
% The subsampled signal does not provide a good summary of the original
% signal as it ends up choosing some elements in the signal while
% elementing remaining elements. It appears that subsampling operation is
% better at capturing low-frequency signals in the original signal.
%%
% The sampling operation is linear because it can be expressed as a matrix
% multiplication aX = b, where the system X is an identity matrix with some
% of the diagonal elements replaced with 0s, a is the original signal and 
% b is the subsampled signal.
%%
% If the input a is shifted, the 1s in the diagonal of X will now be
% multiplied by different input values which will result in a different
% output. Therefore, the subsampling operation is not shift-invariant.

%% b)
% The EEG signal can be transformed into the frequency domain by performing
% fft over the signal. We can also compute the shifted fft by using
% fftshift to center the DC component of the fft. The frequency range goes
% from 0:N-1 and is scaled by the sampling frequency and the length of the
% signal vector N. The shifted frequency scale goes from -N/2 to N/2 - 1
% with same scaling. Plotting the FFT and the shifted FFT, we get:

%%
fs = 120; % sampling frequency
N = length(sig); % length of the signal vector
f = (0:N-1) * fs/N; % creating the frequency vector
fshift = (-N/2: (N/2)-1) * fs/N; % creating a shifted frequency vector
F_sig = fft(sig); % computing the Fourier Transform of signal
F_shift_sig = fftshift(F_sig); % Shifting the Fourier Transform so that DC component is in the middle

figure();
plot(f, abs(F_sig))
xlabel('Frequency (Hz)')
ylabel('Amplitiude')
title('FFT of signal')
figure();
plot(fshift, abs(F_shift_sig))
xlabel('Frequency (Hz)')
ylabel('Amplitiude')
title('FFTshift of signal')

%%
% The strongest signal is obtained at 12 Hz which belongs to the Alpha band
% at 36 Hz which belongs to the Gamma band. I am unsure of the exact source
% of this signal. Here is the thought process that I have went through. At
% first instance, I expected there to be line noise in the signal since its
% an EEG signal. But 36 Hz is too low a frequency for line noise. It could
% just be some neural activity related to the task which should give signal
% in the gamma band of the frequency range. However, this is unlikely to
% give a peak at a single frequency. But then this is synthetic data, so
% maybe that's what it is signifying? Another way to look at it is that 36
% Hz is a second harmonic of 12 Hz. However, harmonics in fft generally
% exhibit lower amplitude than the fundamental. Here the fundamental of
% second harmonic is higher than fundamental (absurd?!), and the first
% harmonic is missing. So I am unsure of the source of the 36 Hz signal
% here.

%% c)
% The bandWiseReconstruct computes the signalPart in a given time-range, for
% a given fftsig within a frequency band. It does so by first computing a
% vector of zeros of length of F_sig and then adding ones at frequencies of
% interest within a given bname. It then takes an element-wise product of
% F_sig with this vector to create an FsigPart which has amplitudes at
% frequencies of interest and is 0 otherwise:
bandnames = ["Delta", "Theta", "Alpha", "Beta", "Merged"]; % array of frequency bands, merged is the entire frequency range
for bname = bandnames
    signalPart = bandWiseReconstruct(time, F_sig, bname); % computing signalPart from F_sig for given frequency bandname
end
%%
% We can see that since the FFT of the signal only has peaks in the alpha
% band and the gamma band, the reconstructed signal from these bands has
% some structure to it whereas for other frequencies, we only see noise
% with amplitude of the signal very close to 0.

%% d)
% The upsampled sigals after downsampling can be computed by creating an
% array of zeros with 1s at positions of downsampling vector and then
% taking an element-wise product of this vetor with the signal. The fft and
% fftshift can then be computed for this upsampled signal.
%%
ds_facts = [2, 3, 4]; % downsampling factors
for fct = ds_facts
    sig_downsamp_pos = zeros(1, length(sig));
    sig_downsamp_pos(fct:fct:end) = 1; % Creating an array of ones at positons where sub-sampled frequencies will be
    sig_upsamp = sig .* sig_downsamp_pos; % Upsampling by computing element-wise product of signal with downsampled positions
    F_sig_upsamp = fft(sig_upsamp); % Computing FFT of upsampled signal
    F_sig_upsamp_shift = fftshift(F_sig_upsamp); % Computing FFTshift of upsampled signal
    
    figure();
    plot(fshift, abs(F_sig_upsamp_shift)); % Plotting amplitudes of shifted FFT
    xlabel('Frequency (Hz)')
    ylabel('Amplitiude')
    title(['FFT of signal sampled at k = ', num2str(fct)])
end

%%
% The downsampling and upsampling happening over here is naive. This
% results in artifacts in the reconstructed signal. The original sampling
% frequency is 120 Hz. Upon downsampling and upsampling, the sampling
% frequency becomes 120/k, where k is the downsampling factor. Hence, the
% Nyquist frequency of the downsampled signal will be 120/2k. For k = 2,
% Nyquist frequency is 120/4 = 40 Hz. The maximum frequency in the original
% signal was 36 Hz which is below Nyquist and hence there is no aliasing.
% However, since the signal is downsampled and upsampled, it creates two
% additional peaks at 60 - 12 = 48 Hz and 60 - 36 = 24 Hz. For k = 3, the
% Nyquist frequency is 120/6 = 20 Hz which is below the maximum frequency
% in the signal resulting in aliasing. Thus we see that the amplitude of
% the first peak in fft is higher than the second. The same happens in the
% case of k = 4. In order to avoid aliasing, signal should be low-pass
% filtered to ensure that there is no component in the downsampled signal
% that is above the Nyquist frequency of the downsampled signal.

%%

%% Functions
function signalPart = bandWiseReconstruct(time, Fsig, bandname)
    % Defining frequency bands and their min and max frequency ranges
    bnames = ["Delta", "Theta", "Alpha", "Beta", "Merged"];
    freqs = [[0, 4, 8, 16, 0]; ...
        [4, 7, 15, 31, 60]];
    band_freqs = freqs(:, bnames == bandname); % Computing the min and max frequency bounds for the given bandname    
    bvec = zeros(1, length(Fsig));
    bvec(band_freqs(1) + 1: band_freqs(2) + 1) = 1; % Creating a vector of zeros with ones at frequencies of interests
    FsigPart = Fsig .* bvec; % Taking an element-wise product of Fsig with bvec to create Fsig with amp values at frequencies of intrest and 0 otherwise
    signalPart = ifft(FsigPart); % Computing inverse FFT of FsigPart
    
    figure()
    plot(time, real(signalPart), 'ro-') % The recomputed signal has imaginary parts which are not of our interest since the signal has only real values
    xlabel('Time (s)')
    ylabel('Voltage (V)')
    title(['Reconstructed EEG Signal at ', bandname])
    
end
##### SOURCE END #####
--></body></html>