
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Q3</title><meta name="generator" content="MATLAB 9.9"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2021-10-10"><meta name="DC.source" content="Q3.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#2">a)</a></li><li><a href="#41">b)</a></li><li><a href="#55">c)</a></li></ul></div><pre class="codeinput">clear; clc; close <span class="string">all</span>;
</pre><h2 id="2">a)</h2><pre class="codeinput">load(<span class="string">'constrainedLS.mat'</span>)
</pre><p>The original optimization problem can be stated as:</p><p><img src="Q3_eq07123310368397829787.png" alt="$min_{\vec{\beta}} \sum_n(\vec{\beta}^T \vec{d_n})^2$">, s.t. <img src="Q3_eq09663779667729532508.png" alt="$\vec{\beta}^T\vec{w} = 1$"></p><p>Let D be the data matrix which has the data points as its rows and the beta is the vector of the parameters that we are interested in. Hence <img src="Q3_eq14313525122008898472.png" alt="$$D\vec{\beta} $$"> becomes a vector with nth row being <img src="Q3_eq16380786823951483796.png" alt="$$\vec{\beta}^T \vec{d_n} $$"> or equivalently <img src="Q3_eq03677726814596081076.png" alt="$$\vec{d_n}^T \vec{\beta} $$"></p><p>Using the definition of the norm, we can then see that:</p><p><img src="Q3_eq01234828430933268974.png" alt="$||D\vec{\beta}||^2 = \sum_n (\vec{\beta}^T \vec{d_n})^2$"></p><p>Thus, the optimization problem can be re-written in the matrix form as:</p><p><img src="Q3_eq10575343511923564538.png" alt="$min_{\vec{\beta}} ||D\vec{\beta}||^2$">, s.t. <img src="Q3_eq09663779667729532508.png" alt="$\vec{\beta}^T\vec{w} = 1$"></p><p>Now we can simplify the problem by performing SVD over the data matrix D. Doing so, we get:</p><p><img src="Q3_eq01404256479802272177.png" alt="$D = USV^T$"></p><p>Substituting the SVD back into the matrix form of the optimization problem:</p><p><img src="Q3_eq01799170159817410783.png" alt="$min_{\vec{\beta}} ||USV^T\vec{\beta}||^2$">, s.t. <img src="Q3_eq09663779667729532508.png" alt="$\vec{\beta}^T\vec{w} = 1$"></p><p>Since U is a transformation matrix, we can ignore it for the minimization problem:</p><p><img src="Q3_eq09549004578212582496.png" alt="$min_{\vec{\beta}} ||SV^T\vec{\beta}||^2$">, s.t. <img src="Q3_eq09663779667729532508.png" alt="$\vec{\beta}^T\vec{w} = 1$"></p><p>Let <img src="Q3_eq11911988911778130905.png" alt="$$\vec{\beta^*} = V^T\vec{\beta} $$"></p><p>Therefore,</p><p><img src="Q3_eq14940657186235510429.png" alt="$\vec{\beta} = V\vec{\beta^*}$"></p><p>The minimization problem then becomes:</p><p><img src="Q3_eq06347263543927660456.png" alt="$min_{\vec{\beta^*}} ||S\vec{\beta^*}||^2$">, s.t. <img src="Q3_eq02104307838151712963.png" alt="$(V\vec{\beta^*})^T \vec{w} = 1$"></p><p><img src="Q3_eq06347263543927660456.png" alt="$min_{\vec{\beta^*}} ||S\vec{\beta^*}||^2$">, s.t. <img src="Q3_eq16642034872760397834.png" alt="$\vec{\beta^*}^T V^T \vec{w} = 1$"></p><p>Let <img src="Q3_eq08923783834845410664.png" alt="$$\vec{w^*} = V^T \vec{w} $$"></p><p>Therefore,</p><p><img src="Q3_eq06347263543927660456.png" alt="$min_{\vec{\beta^*}} ||S\vec{\beta^*}||^2$">, s.t. <img src="Q3_eq13766148097093169210.png" alt="$\vec{\beta^*}^T \vec{w^*} = 1$"></p><p>Now S is a diagonal matrix of shape 300 * 2. Hence it has the first two rows with non-zero diagonal elements. All the remaining rows of S are zeros. Therefore, the transformation of <img src="Q3_eq14564501750399376238.png" alt="$$\vec{\beta^*} $$"> by S creates a 300 dimensional vector with only two entries and the other entries being 0. Hence, the minimization problem can be simplified by considering only the first two rows of S. Let this matrix be called S*. The optimization problem can hence be restated as:</p><p><img src="Q3_eq04143736850734796579.png" alt="$min_{\vec{\beta^*}} ||S^*\vec{\beta^*}||^2$">, s.t. <img src="Q3_eq05159163262166206518.png" alt="$\vec{\beta^*}^{T}\vec{w^*} = 1$"></p><p>Let <img src="Q3_eq11096557501790372249.png" alt="$$\tilde{\beta} = S^{*} \vec{\beta^*} $$"></p><p>Therefore,</p><p><img src="Q3_eq05398591984986654244.png" alt="$\vec{\beta^*} = S^{*\#}\tilde{\beta}$"></p><p>Here <img src="Q3_eq10161477975986712719.png" alt="$$S^{*\#} $$"> is the pseudoinverse of <img src="Q3_eq11822258728136693671.png" alt="$$S^* $$"> and is an orthogonal matrix.</p><p>Thus, we have:</p><p><img src="Q3_eq14785601091150487712.png" alt="$\vec{\beta^*}^T = (S^{*\#}\tilde{\beta})^T =\tilde{\beta}^T S^{*\#}$"></p><p>The optimization problem now becomes:</p><p><img src="Q3_eq05130027646243925451.png" alt="$$min_{\tilde{\beta}} ||\tilde{\beta}||^2$$, s.t. $$\tilde{\beta}^{T}S^{*\#}\vec{w^*} = 1$$"></p><p>Let <img src="Q3_eq08043611023958958513.png" alt="$$\tilde{w} = S^{*\#} \vec{w^*} $$"></p><p>Therefore,</p><p><img src="Q3_eq03758784790686567222.png" alt="$min_{\tilde{\beta}} ||\tilde{\beta}||^2$">, s.t. <img src="Q3_eq14521495228645495154.png" alt="$\tilde{\beta}^{T}\tilde{w} = 1$"></p><p>We can re-write <img src="Q3_eq17715549874495152721.png" alt="$$\tilde{\beta} $$"> and <img src="Q3_eq06611732901366278955.png" alt="$$\tilde{w} $$"> in terms of <img src="Q3_eq04666978853629574678.png" alt="$$\vec{\beta} $$"> and <img src="Q3_eq13025417811621045447.png" alt="$$\vec{w} $$"></p><p><img src="Q3_eq01646469460408484843.png" alt="$\tilde{\beta} = S^* V^T \vec{\beta}$"></p><p><img src="Q3_eq01154461727818133541.png" alt="$\tilde{w} = S^{*\#} V^T \vec{w}$"></p><h2 id="41">b)</h2><p>Performing SVD on the original data:</p><pre class="codeinput">[U, S, V] = svd(data);
Ss = S(1:2, :);
</pre><p>The shortest vector <img src="Q3_eq17640732332798045634.png" alt="$$\tilde{\beta}_{opt} $$"> is the one that lies along the direction of <img src="Q3_eq06611732901366278955.png" alt="$$\tilde{w} $$"> . Hence the angle between <img src="Q3_eq17640732332798045634.png" alt="$$\tilde{\beta}_{opt} $$"> and <img src="Q3_eq06611732901366278955.png" alt="$$\tilde{w} $$"> is <img src="Q3_eq04281240290789119141.png" alt="$$0^{\circ} $$"></p><p>The constraint is basically a dot product of the vectors and hence can also be written as:</p><p><img src="Q3_eq16832405326209887930.png" alt="$$\tilde{\beta}^{T} \tilde{w} = ||\tilde{\beta}||.||\tilde{w}||cos \theta&#xA;= 1 $$"></p><p>Since <img src="Q3_eq12904330117749919323.png" alt="$$\theta = 0 $$">, we have <img src="Q3_eq14123797619277004296.png" alt="$$cos \theta = 1 $$"></p><p>The constraint then becomes:</p><p><img src="Q3_eq05957166633105578360.png" alt="$$||\tilde{\beta}_{opt}||.||\tilde{w}|| = 1 $$"></p><p>Therefore,</p><p><img src="Q3_eq01458732569676279621.png" alt="$||\tilde{\beta}_{opt}|| = \frac{1}{||\tilde{w}||}$"></p><p>This gives the length of <img src="Q3_eq17640732332798045634.png" alt="$$\tilde{\beta}_{opt} $$">. This vector points in the same direction as <img src="Q3_eq06611732901366278955.png" alt="$$\tilde{w} $$"> and hence the vector can be represented as:</p><p><img src="Q3_eq08113556737672183424.png" alt="$\tilde{\beta}_{opt} = ||\tilde{\beta}_{opt}|| \frac{\tilde{w}}{||\tilde{w}||}$"></p><p>Substituting the length of <img src="Q3_eq17640732332798045634.png" alt="$$\tilde{\beta}_{opt} $$"> calculated above:</p><p><img src="Q3_eq17317654284518411393.png" alt="$\tilde{\beta}_{opt} = \frac{\tilde{w}}{||\tilde{w}||^2}$"></p><pre class="codeinput">w_tilde = pinv(Ss)*V'*w;
w_tilde_hat = w_tilde/sqrt(sum(w_tilde.^2));
beta_tilde_opt = w_tilde_hat * 1/sqrt(sum(w_tilde.^2));
beta_tilde_opt_fplot = [zeros(2, 1), beta_tilde_opt];
slope_beta_tilde_opt = beta_tilde_opt(2)/beta_tilde_opt(1);
slope_perp = -1/slope_beta_tilde_opt;
intercept_perp = beta_tilde_opt(2) - slope_perp * beta_tilde_opt(1);
figure(1);
plot(beta_tilde_opt_fplot(1, :), beta_tilde_opt_fplot(2, :), <span class="string">'r-o'</span>, <span class="string">'MarkerSize'</span>, 5, <span class="keyword">...</span>
    <span class="string">'DisplayName'</span>, <span class="string">'$\tilde{\beta}_{opt}$'</span>)
hold <span class="string">on</span>;
x_perp = xlim;
y_perp = slope_perp * x_perp + intercept_perp * [1, 1];
plot(x_perp, y_perp, <span class="string">'b'</span>, <span class="string">'LineWidth'</span>, 2, <span class="keyword">...</span>
    <span class="string">'DisplayName'</span>, <span class="string">'perp line'</span>)
title(<span class="string">'Space of beta tilde'</span>)
hl = legend(<span class="string">'show'</span>);
set(hl, <span class="string">'Interpreter'</span>, <span class="string">'latex'</span>)
</pre><img vspace="5" hspace="5" src="Q3_01.png" alt=""> <h2 id="55">c)</h2><p>From the previous transformations we have:</p><p><img src="Q3_eq01646469460408484843.png" alt="$\tilde{\beta} = S^* V^T \vec{\beta}$"></p><p>Therefore,</p><p><img src="Q3_eq17850296200356377602.png" alt="$\vec{\beta} = (S^* V^T)^{-1} \tilde{\beta}$"></p><p>Therefore,</p><p><img src="Q3_eq01179698305447405401.png" alt="$\vec{\beta} = (V^T)^{-1} (S^*)^{-1} \tilde{\beta}$"></p><p>Therefore,</p><p><img src="Q3_eq06762818238955102559.png" alt="$\vec{\beta} = V S^{*\#} \tilde{\beta}$"></p><p>Computing <img src="Q3_eq04666978853629574678.png" alt="$$\vec{\beta} $$"> from <img src="Q3_eq17715549874495152721.png" alt="$$\tilde{\beta} $$"> we just computed, we get:</p><pre class="codeinput">beta_opt = V * pinv(Ss)*beta_tilde_opt;
beta_opt_fplot = [zeros(2, 1), beta_opt];
w_fplot = [zeros(2, 1), w];
</pre><p>The original contraint line is perpendicular to the projection of <img src="Q3_eq03007921319120235727.png" alt="$$\vec{\beta}_{opt} $$"> on <img src="Q3_eq13025417811621045447.png" alt="$$\vec{w} $$"></p><p>The projection can be computed as:</p><p><img src="Q3_eq16981010158596683985.png" alt="$$\beta_{opt, proj} = \vec{\beta_{opt}}cos \theta $$"></p><p>where, <img src="Q3_eq01893715916487034068.png" alt="$$\phi $$"> is the angle between the two vectors, the cosine of which can be computed as:</p><p><img src="Q3_eq00760050311043423633.png" alt="$$cos \phi = \frac{\vec{\beta}_{opt}'&#xA;\vec{w}}{||\vec{\beta}_{opt}||.||\vec{w}||} $$"></p><pre class="codeinput">scalar_proj = beta_opt' * w / norm(w, 2);
beta_opt_proj = scalar_proj * w / norm(w, 2);
beta_opt_proj_fplot = [zeros(2, 1), beta_opt_proj];


slope_beta_proj = beta_opt_proj(2)/beta_opt_proj(1);
slope_perp_org = -1/slope_beta_proj;
intercept_perp_org = beta_opt_proj(2) - slope_perp_org * beta_opt_proj(1);

figure(2);
plot(beta_opt_fplot(1, :), beta_opt_fplot(2, :), <span class="string">'r-'</span>, <span class="string">'MarkerSize'</span>, 5, <span class="keyword">...</span>
    <span class="string">'DisplayName'</span>, <span class="string">'$\vec{\beta}_{opt}$'</span>)
hold <span class="string">on</span>;
plot(w_fplot(1, :), w_fplot(2, :), <span class="string">'k-'</span>, <span class="string">'MarkerSize'</span>, 5, <span class="keyword">...</span>
    <span class="string">'DisplayName'</span>, <span class="string">'$\vec{w}$'</span>)

plot(data(:, 1), data(:, 2), <span class="string">'o'</span>)
x_perp_org = xlim;
y_perp_org = slope_perp_org * x_perp_org + intercept_perp_org * [1, 1];
plot(x_perp_org, y_perp_org, <span class="string">'b'</span>, <span class="string">'LineWidth'</span>, 2, <span class="keyword">...</span>
    <span class="string">'DisplayName'</span>, <span class="string">'perp line'</span>)
title(<span class="string">'Original space'</span>)
hl = legend(<span class="string">'show'</span>);
set(hl, <span class="string">'Interpreter'</span>, <span class="string">'latex'</span>)
</pre><img vspace="5" hspace="5" src="Q3_02.png" alt=""> <p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2020b</a><br></p></div><!--
##### SOURCE BEGIN #####
clear; clc; close all;

%% a)
load('constrainedLS.mat')

%%
% The original optimization problem can be stated as:
%%
% $min_{\vec{\beta}} \sum_n(\vec{\beta}^T \vec{d_n})^2$, s.t. $\vec{\beta}^T\vec{w} = 1$
%%
% Let D be the data matrix which has the data points as its rows and the
% beta is the vector of the parameters that we are interested in. Hence
% $$D\vec{\beta} $$ becomes a vector with nth row being $$\vec{\beta}^T
% \vec{d_n} $$ or equivalently $$\vec{d_n}^T \vec{\beta} $$
%%
% Using the definition of the norm, we can then see that:
%%
% $||D\vec{\beta}||^2 = \sum_n (\vec{\beta}^T \vec{d_n})^2$
%%
% Thus, the optimization problem can be re-written in the matrix form as:
%%
% $min_{\vec{\beta}} ||D\vec{\beta}||^2$, s.t. $\vec{\beta}^T\vec{w} = 1$
%%
% Now we can simplify the problem by performing SVD over the data matrix D.
% Doing so, we get:
%%
% $D = USV^T$
%%
% Substituting the SVD back into the matrix form of the optimization
% problem:
%%
% $min_{\vec{\beta}} ||USV^T\vec{\beta}||^2$, s.t. $\vec{\beta}^T\vec{w} = 1$
%%
% Since U is a transformation matrix, we can ignore it for the minimization
% problem:
%% 
% $min_{\vec{\beta}} ||SV^T\vec{\beta}||^2$, s.t. $\vec{\beta}^T\vec{w} = 1$
%%
% Let $$\vec{\beta^*} = V^T\vec{\beta} $$
%%
% Therefore,
%%
% $\vec{\beta} = V\vec{\beta^*}$
%%
% The minimization problem then becomes:
%%
% $min_{\vec{\beta^*}} ||S\vec{\beta^*}||^2$, s.t. $(V\vec{\beta^*})^T \vec{w} = 1$
%% 
% $min_{\vec{\beta^*}} ||S\vec{\beta^*}||^2$, s.t. $\vec{\beta^*}^T V^T \vec{w} = 1$
%%
% Let $$\vec{w^*} = V^T \vec{w} $$
%%
% Therefore,
%%
% $min_{\vec{\beta^*}} ||S\vec{\beta^*}||^2$, s.t. $\vec{\beta^*}^T \vec{w^*} = 1$
%%
% Now S is a diagonal matrix of shape 300 * 2. Hence it has the first two
% rows with non-zero diagonal elements. All the remaining rows of S are zeros.
% Therefore, the transformation of $$\vec{\beta^*} $$ by S creates a 300
% dimensional vector with only two entries and the other entries being 0.
% Hence, the minimization problem can be simplified by considering only the
% first two rows of S. Let this matrix be called S*. The optimization
% problem can hence be restated as:
%%
% $min_{\vec{\beta^*}} ||S^*\vec{\beta^*}||^2$, s.t. $\vec{\beta^*}^{T}\vec{w^*} = 1$
%%
% Let $$\tilde{\beta} = S^{*} \vec{\beta^*} $$
%%
% Therefore,
%%
% $\vec{\beta^*} = S^{*\#}\tilde{\beta}$
%%
% Here $$S^{*\#} $$ is the pseudoinverse of $$S^* $$ and is an orthogonal
% matrix.
%%
% Thus, we have:
%%
% $\vec{\beta^*}^T = (S^{*\#}\tilde{\beta})^T =\tilde{\beta}^T S^{*\#}$
%%
% The optimization problem now becomes:
%%
% $$min_{\tilde{\beta}} ||\tilde{\beta}||^2$$, s.t. $$\tilde{\beta}^{T}S^{*\#}\vec{w^*} = 1$$
%%
% Let $$\tilde{w} = S^{*\#} \vec{w^*} $$
%%
% Therefore,
%%
% $min_{\tilde{\beta}} ||\tilde{\beta}||^2$, s.t. $\tilde{\beta}^{T}\tilde{w} = 1$
%%
% We can re-write $$\tilde{\beta} $$ and $$\tilde{w} $$ in terms of $$\vec{\beta} $$
% and $$\vec{w} $$
%%
% $\tilde{\beta} = S^* V^T \vec{\beta}$
%%
% $\tilde{w} = S^{*\#} V^T \vec{w}$

%% b)
% Performing SVD on the original data:
%%
[U, S, V] = svd(data);
Ss = S(1:2, :);
%%
% The shortest vector $$\tilde{\beta}_{opt} $$ is the one that lies along the
% direction of $$\tilde{w} $$ . Hence the angle between $$\tilde{\beta}_{opt} $$
% and $$\tilde{w} $$ is $$0^{\circ} $$
%%
% The constraint is basically a dot product of the vectors and hence can
% also be written as:
%%
% $$\tilde{\beta}^{T} \tilde{w} = ||\tilde{\beta}||.||\tilde{w}||cos \theta
% = 1 $$
%%
% Since $$\theta = 0 $$, we have $$cos \theta = 1 $$
%%
% The constraint then becomes:
%%
% $$||\tilde{\beta}_{opt}||.||\tilde{w}|| = 1 $$
%%
% Therefore,
%%
% $||\tilde{\beta}_{opt}|| = \frac{1}{||\tilde{w}||}$
%%
% This gives the length of $$\tilde{\beta}_{opt} $$. This vector points in
% the same direction as $$\tilde{w} $$ and hence the vector can be
% represented as:
%%
% $\tilde{\beta}_{opt} = ||\tilde{\beta}_{opt}|| \frac{\tilde{w}}{||\tilde{w}||}$
%%
% Substituting the length of $$\tilde{\beta}_{opt} $$ calculated above:
%%
% $\tilde{\beta}_{opt} = \frac{\tilde{w}}{||\tilde{w}||^2}$

w_tilde = pinv(Ss)*V'*w;
w_tilde_hat = w_tilde/sqrt(sum(w_tilde.^2));
beta_tilde_opt = w_tilde_hat * 1/sqrt(sum(w_tilde.^2));
beta_tilde_opt_fplot = [zeros(2, 1), beta_tilde_opt];
slope_beta_tilde_opt = beta_tilde_opt(2)/beta_tilde_opt(1);
slope_perp = -1/slope_beta_tilde_opt;
intercept_perp = beta_tilde_opt(2) - slope_perp * beta_tilde_opt(1);
figure(1);
plot(beta_tilde_opt_fplot(1, :), beta_tilde_opt_fplot(2, :), 'r-o', 'MarkerSize', 5, ...
    'DisplayName', '$\tilde{\beta}_{opt}$')
hold on;
x_perp = xlim;
y_perp = slope_perp * x_perp + intercept_perp * [1, 1];
plot(x_perp, y_perp, 'b', 'LineWidth', 2, ...
    'DisplayName', 'perp line')
title('Space of beta tilde')
hl = legend('show');
set(hl, 'Interpreter', 'latex')

%% c)
% From the previous transformations we have:
%%
% $\tilde{\beta} = S^* V^T \vec{\beta}$
%%
% Therefore,
%%
% $\vec{\beta} = (S^* V^T)^{-1} \tilde{\beta}$
%%
% Therefore,
%%
% $\vec{\beta} = (V^T)^{-1} (S^*)^{-1} \tilde{\beta}$
%%
% Therefore,
%%
% $\vec{\beta} = V S^{*\#} \tilde{\beta}$
%%
% Computing $$\vec{\beta} $$ from $$\tilde{\beta} $$ we just computed, we
% get:
%%
beta_opt = V * pinv(Ss)*beta_tilde_opt;
beta_opt_fplot = [zeros(2, 1), beta_opt];
w_fplot = [zeros(2, 1), w];
%%
% The original contraint line is perpendicular to the projection of
% $$\vec{\beta}_{opt} $$ on $$\vec{w} $$
%%
% The projection can be computed as:
%%
% $$\beta_{opt, proj} = \vec{\beta_{opt}}cos \theta $$
%%
% where, $$\phi $$ is the angle between the two vectors, the cosine of which
% can be computed as:
%%
% $$cos \phi = \frac{\vec{\beta}_{opt}'
% \vec{w}}{||\vec{\beta}_{opt}||.||\vec{w}||} $$
scalar_proj = beta_opt' * w / norm(w, 2);
beta_opt_proj = scalar_proj * w / norm(w, 2);
beta_opt_proj_fplot = [zeros(2, 1), beta_opt_proj];


slope_beta_proj = beta_opt_proj(2)/beta_opt_proj(1);
slope_perp_org = -1/slope_beta_proj;
intercept_perp_org = beta_opt_proj(2) - slope_perp_org * beta_opt_proj(1);

figure(2);
plot(beta_opt_fplot(1, :), beta_opt_fplot(2, :), 'r-', 'MarkerSize', 5, ...
    'DisplayName', '$\vec{\beta}_{opt}$')
hold on;
plot(w_fplot(1, :), w_fplot(2, :), 'k-', 'MarkerSize', 5, ...
    'DisplayName', '$\vec{w}$')

plot(data(:, 1), data(:, 2), 'o')
x_perp_org = xlim;
y_perp_org = slope_perp_org * x_perp_org + intercept_perp_org * [1, 1];
plot(x_perp_org, y_perp_org, 'b', 'LineWidth', 2, ...
    'DisplayName', 'perp line')
title('Original space')
hl = legend('show');
set(hl, 'Interpreter', 'latex')

##### SOURCE END #####
--></body></html>